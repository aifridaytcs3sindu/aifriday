# ============================================

# .copilot-instructions

# Universal Instructions for API Test Generation (Playwright + Cucumber + JavaScript)

# ============================================

## üß≠ Objective

When the user provides a Swagger URL or Swagger JSON file and specifies one or more API endpoints (e.g., `/store`, `/user`, `/pet`), generate a **complete Playwright + Cucumber API test suite in JavaScript/TypeScript** for those endpoints.

Assume:
* Node.js v18+ (ESM syntax enabled)
* Playwright v1.45+ (for `APIRequestContext`)
* Cucumber.js v9+
* Chai v5+ for assertions
* The Swagger endpoint provides valid request/response schema.
* The goal is to generate **fully automated regression tests** that can be executed and retried until all tests pass.

---

## üß© Code Architecture

The generated project must follow this structure:

```
features/
‚îú‚îÄ‚îÄ step_definitions/
‚îÇ     ‚îî‚îÄ‚îÄ <endpoint1>_steps.js
      ‚îî‚îÄ‚îÄ <endpoint2>_steps.js
‚îú‚îÄ‚îÄ support/
‚îÇ     ‚îú‚îÄ‚îÄ world.js
‚îÇ     ‚îî‚îÄ‚îÄ hooks.js
‚îú‚îÄ‚îÄ <endpoint1>.feature
‚îú‚îÄ‚îÄ <endpoint2>.feature
helpers/
‚îú‚îÄ‚îÄ <endpoint1>ApiHelper.js
‚îú‚îÄ‚îÄ <endpoint2>ApiHelper.js
‚îî‚îÄ‚îÄ retryHelper.js
playwright.config.js
package.json
README.md
````

**Naming Rules**

* Use lowercase filenames and camelCase function names.
* Examples:
  * `store_steps.js`
  * `storeApiHelper.js`
  * `retryHelper.js`
  * Functions: `createOrder()`, `getOrderById()`, `deleteOrder()`

---

## ‚öôÔ∏è Functional Requirements

### 1. Generate POJOs (Data Models)

* Based on Swagger schema definitions for the provided endpoint.
* Use **JavaScript classes** to represent request and response objects.
* Include constructors and default values for required fields.

### 2. Create Feature File (.feature)

* For each endpoint**, generate:
   - A **distinct feature file** named after the endpoint, for example:
       * `store.feature` for `/store` endpoint
       * `order.feature` for `/order` endpoint
* Written in **Gherkin syntax** (`Given`, `When`, `Then`).
* Each endpoint operation (`POST`, `GET`, `DELETE`, `PUT` if available) should include:
  * Valid scenario (happy path)
  * Invalid scenario (error handling)
* Follow conditional rules by HTTP method:
| Method | Allowed Negative Codes |
|---------|------------------------|
| GET     | 404, 500              |
| POST    | 400, 401, 404, 500    |
| PUT     | 400, 404, 500         |
| DELETE  | 400, 404, 500         |
---

### 3. Create Step Definitions

* Implement using Playwright‚Äôs `request.newContext()` API.
* For each endpoint, generate a separate step definition file that contains steps specific to that endpoint.
  * For example, if the endpoint is /store, create features/step_definitions/store_steps.js.
  * Ensure each step definition file includes only the relevant steps for that endpoint, avoiding any cross-contamination between different API endpoints.
* Steps must:
  * Perform HTTP requests using endpoint data from Swagger.
  * Use `chai.expect` for response assertions.
  * Reuse helper methods for each operation.
* Example: `features/step_definitions/store_steps.js`

### 4. Create Helper Functions

* Each endpoint has a helper file, e.g., `helpers/storeApiHelper.js`.
* Each helper exports methods like `createOrder()`, `getOrder()`, `deleteOrder()`.
* Use Playwright‚Äôs request context to make calls and return parsed JSON responses.

### 5. Custom World & Hooks

* `features/support/world.js`: Initializes Playwright‚Äôs request context.
* `features/support/hooks.js`: Adds setup and teardown hooks (`Before`, `After`).

### 6. Retry Logic

* Create `helpers/retryHelper.js` to retry failed requests or assertions.
* Default retry configuration:
  * Attempts: 3
  * Delay: 500ms (exponential backoff)
* Retry logic must re-execute only the failed step or scenario.

### 7. Config & Execution

* `playwright.config.js`: Sets baseURL from environment variable or Swagger host.
* `package.json`:

  ```json
  {
    "type": "module",
    "scripts": {
      "test": "cucumber-js --require 'features/**/*.js' --publish-quiet",
      "test:watch": "nodemon --exec \"npm test\""
    }
  }
  ```

### 8. Reporting

* Generate reports in:
  * `/reports/cucumber-report.html`
  * `/reports/cucumber-report.json`
* Include step-level logs and error stack traces.
* Display execution summary in console output.

---

## üß† Self-Healing & Failure Recovery

If a test fails:

1. Analyze error logs to identify cause (e.g., status code mismatch, missing field, schema deviation).
2. Auto-adjust payload, endpoint URL, or assertions as needed.
3. Regenerate the failed step definition file dynamically.
4. Retry only the failed scenario (up to 3 times).
5. Stop only after all tests pass successfully.

---
## üß† Self-Healing & Adaptive Negative Handling

If tests fail due to unsupported negative scenarios or timeouts:

1. **Analyze the failure type**
   - If response consistently returns success (200) or timeout for simulated errors, treat the negative test as *unsupported by API*.

2. **Adaptive Pruning Logic**
   - Remove or skip such scenarios automatically.
   - Mark them as `"Not Applicable"` in the Cucumber HTML/JSON report.

3. **Auto-Refinement**
   - Preserve only *realistic* negative tests such as `404 Not Found`.
   - Exclude unsupported `400`, `401`, `500` scenarios.

4. **Learning Memory**
   - If a scenario is skipped 3 consecutive times, exclude it from regenerated feature files permanently.

5. **Retry Flow**
   - Regenerate and re-run until all active tests pass successfully.

This ensures:
‚úÖ No false negatives  
‚úÖ Test suite aligns with actual API behavior  
‚úÖ Fully self-healing adaptive regression system

---
## üõ†Ô∏è **Authentication Handling**:

When generating API tests,
- Handle Basic authentication, Bearer Token, or API Key as defined in Swagger.  
- Encode Basic Auth as `Authorization: Basic <base64>`.
- Ensure that authentication is included for every API call requiring authentication, especially for endpoints that involve user data or secure operations.
---

## üåê **JSON Parsing Rules**

When parsing Swagger/OpenAPI **JSON** files:
* Accept **JSON file format** (`swagger.json` or `openapi.json`).
* Extract the following information:
  * Host and basePath
  * All available `paths` and their operations (GET/POST/PUT/DELETE)
  * Request/response schema from `definitions` or `components/schemas`
  * Example payloads if present
* Use these definitions to auto-generate request classes, payload builders, and assertions.

---

## üß™ Test Generation Workflow

When the user provides a **Swagger URL** or **Swagger JSON file** and specifies one or more API endpoints:
1. **Parse the Swagger definition** to extract all available endpoints.
2. Identify the specified endpoint(s) and their operations.
3. Generate   
   - **Data models** (JavaScript classes) 
   - **Gherkin feature files**
   - **Step definitions**
   - **Helper functions** 
   - **Hooks** and **world.js** files
4. Automatically create all required files in the current project. 
5. Run tests, fix any issues automatically, and retry until all pass. 
6. Produce a summary and store results in `/reports/`.

---

## üßæ README.md Generation

Automatically include:
* Project overview
* Setup instructions (`npm install`, `npm test`)
* Folder structure explanation
* Swagger endpoint customization guide
* Adding new endpoint test instructions

---

## ‚úÖ Completion Criteria

All generated test scripts must:
* Execute successfully using `npm test`.
* Validate response codes, payloads, and schemas.
* Log meaningful console output.
* Regenerate or self-heal any failing steps.
* Produce a readable Cucumber HTML report.
* Be executable for any given Swagger endpoint by simply providing the Swagger URL and endpoint name.

---
## üó£Ô∏è **Prompt Schema (How to Interpret User Prompts)**

When the user provides a **Swagger URL** or **Swagger JSON file** and specifies one or more API endpoints (e.g., `/store`, `/user`, `/pet`), the following steps should be taken:

1. **Parse the Swagger input**:
   * If the user provides a **Swagger URL**, fetch and parse the Swagger definition from the provided URL.
   * If the user provides a **Swagger JSON file**, parse the locally uploaded Swagger JSON file.
   
2. **Swagger API Definition Handling**:
   * The system must be able to handle both **remote Swagger URLs** and **local Swagger JSON files** for generating API tests.
   #### 1. Remote Swagger URL:
   * If the user provides a **Swagger URL** (e.g., `https://example.com/swagger.json`), the system should:
     * Automatically fetch the Swagger JSON definition from the provided URL.
     * Parse the definition to extract endpoint details, operations, and schemas.
     * Ensure that any required authentication (e.g., Basic Auth or Bearer tokens) is handled for the API request.
   #### 2. Local Swagger JSON File:
   * If the user provides a **local Swagger JSON file**, the system should:
     * Accept the uploaded file and parse the Swagger JSON directly from the local file system.
     * Ensure that the file follows the Swagger 2.0 or OpenAPI 3.0 format.
     * Automatically detect and handle the available endpoints, methods, and authentication as defined within the file.

3. Identify endpoint(s) and operations
4. Generate Playwright + Cucumber tests following the structure.
5. Run and self-heal until all tests pass.
6. Report only realistic negative scenarios.
---




### üìò **User Prompt ‚Äî Generate Swagger API Regression Tests**

Generate **Playwright + Cucumber API test scripts** for all the endpoints defined in /api/salesOrderApi.json.
Each API endpoint (e.g., `/store`, `/user`, `/order`) should have its own `.feature`, `.steps.js`, and helper files.

Please strictly follow the architectural and coding standards defined in the `.copilot-instructions` file at the project root.

---

### **Details**

* **Swagger API Source:** '/api/salesOrderApi.json' 
* **Base Url:** https://pigw-mpcon-ca.marksandspencer.app/swagger-ui.html
* **Authentication:** Basic Authentication (username: intloninordersadNprod and password:0n1n0rder9Ad)
* **Goal:**
  Generate all necessary files (feature, step definitions, API client helper, config) and ensure the tests execute and pass **without any manual intervention**.
* **Operations to Cover:** `POST`, `GET`, `DELETE`, `PUT` (if available)
* **Tech Stack:** Playwright (APIRequestContext) + Cucumber.js + Chai
---

### **Expected Test Coverage**

For **each API operation**, generate:

1. **Positive flow (200)** ‚Äì Valid request and response validation
2. **Negative flows** ‚Äî Generate negative test cases only for applicable HTTP methods:
   - **POST**: `400`, `401`, `404`, `500`.
   - **GET**: `404`, `500`
   - **PUT**: `400`, `404`, `500`
   - **DELETE**: `400`, `404`, `500`
3. **Adaptive Pruning:**  
   Automatically remove or skip unrealistic negative tests that are unsupported by the actual API (e.g., 401 or 500 not implemented).  
   Retain only those that make sense for real API behavior (e.g., 404).


---

### **Execution Behavior**

* Automatically run all tests after generation
* If any failure occurs, debug and fix automatically.
* Retry until all tests pass successfully.
* Fix schema or payload automatically if the Swagger definition changes

---

### ‚úÖ **Completion Criteria**

All generated test suites must:

* Include only realistic positive and negative test coverage
* Execute successfully using `npm test`
* Produce Cucumber HTML and JSON reports under `/reports/`
* Require zero manual intervention
* Conform fully to the `.copilot-instructions` standards.

---
