# REST Assured API Test Generator

**Purpose**: Generate complete REST Assured + Cucumber test suite from Swagger/OpenAPI specification.

**Usage**: `@workspace #file:copilot-instructions.md Generate API tests from Swagger`

---

## üéØ Core Workflow

1. **Check endpoint-config.json** ‚Üí Determine which endpoints to generate tests for
2. **Parse Swagger** ‚Üí Extract endpoints, schemas, authentication
3. **Parse Response Schemas** ‚Üí Get actual field names (response/data/result)
4. **Generate Tests** ‚Üí Feature files + testData.json + step definitions
5. **Validate Coverage** ‚Üí Verify feature files match enabled endpoints
6. **Execute** ‚Üí Run tests, generate reports

---

## üîß Endpoint Selection Process

**CRITICAL**: Always check `endpoint-config.json` before generating tests.

### Configuration Logic

```json
{
  "generateForAllEndpoints": false,  // or true
  "endpoints": [
    {
      "method": "POST",
      "path": "/api/windowsandcamp/v1/listing",
      "controller": "windows-campaigns-controller",
      "enabled": true  // or false
    }
  ]
}
```

**Rules**:
- If `generateForAllEndpoints: true` ‚Üí Parse ALL endpoints from Swagger specification
- If `generateForAllEndpoints: false` ‚Üí Generate tests ONLY for endpoints in the `endpoints` array where `enabled: true`

### Validation Checklist (Post-Generation)

After generating feature files, **ALWAYS validate**:

```bash
# Count enabled endpoints
jq '[.endpoints[] | select(.enabled == true)] | length' endpoint-config.json

# Count generated feature files
ls -1 src/test/resources/features/*.feature | wc -l
```

**Expected Result**: Feature file count should match enabled endpoint count (or exceed if multiple scenarios per endpoint grouped in one file).

### Coverage Verification

**Before marking generation as complete**:
- [ ] All enabled endpoints in `endpoint-config.json` have corresponding feature files
- [ ] Each endpoint has positive scenario (200/201 response)
- [ ] Each endpoint has negative scenario (@no-auth, 401 response)
- [ ] testData.json has entries for all enabled endpoints
- [ ] All feature files compile without errors

---

## ‚ö†Ô∏è CRITICAL RULES

### 1. Swagger Endpoint Parsing

**MANDATORY**: Extract HTTP method, path parameters, and response schema from Swagger.

```
Swagger Navigation:
paths ‚Üí /api/endpoint/{pathParam} 
  ‚Üí [get|post|put|delete|patch]  # ‚Üê Extract HTTP method!
  ‚Üí parameters (optional)         # ‚Üê Check for path/query params
    ‚Üí name, in (path/query), schema.type
  ‚Üí responses ‚Üí 200 
    ‚Üí content ‚Üí application/json ‚Üí schema ‚Üí $ref 
    ‚Üí components ‚Üí schemas ‚Üí ResponseSchemaName ‚Üí properties
```

**Example - GET with Path Parameter**:

```yaml
paths:
  /api/favourites/v1/listing/{season}:
    get:  # ‚Üê Use GET, not POST!
      parameters:
        - name: season
          in: path
          required: true
          schema:
            type: string
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ResponseListFavourites'
```

**Feature File**:

```gherkin
# ‚úÖ CORRECT:
When I send a GET request to "/api/favourites/v1/listing/SM25"

# ‚ùå WRONG:
When I send a POST request to "/api/favourites/v1/listing" with valid payload
```

---

### 2. HTTP Method and Path Parameters

**CRITICAL**: Use correct HTTP method from Swagger, handle path parameters properly.

* **Extract method**: Check Swagger's `get`, `post`, `put`, `delete`, `patch`
* **Path parameters**: Replace `{paramName}` with actual values
  - Example: `/api/favourites/v1/listing/{season}` ‚Üí `/api/favourites/v1/listing/SM25`
  - Check parameter type: integer (3621), string ("SM25"), etc.
* **Feature file**: Use exact HTTP method and resolved path
* **testData.json key**: Strip `/api/` prefix for data lookup
* **NEVER**: Assume POST for all endpoints, use wrong parameter types

### 3. Endpoint Path Alignment

* **Feature file**: `/api/dsbudget/v1/details` (actual API path)
* **testData.json key**: `dsbudget/v1/details` (strip `/api/` prefix)
* **NEVER invent endpoint paths** - use exact paths from Swagger

---

### 4. Flexible Response Validation

**IMPORTANT**: Don't rigidly validate all responses the same way.

* **status field**: Can be `true` or `false` depending on data availability
  - `status: true` ‚Üí Data found/operation successful
  - `status: false` ‚Üí No data found (valid for empty results)
  - **Don't always assert** `status == true`
* **response field**: Can be `null` for non-existent resources
  - Check field exists in schema
  - **Don't assert** `response != null` (null is valid for missing data)
* **Conditional assertions**: Accept business-valid responses
  - "No Records Found" with `status: false` is valid
  - Empty arrays/null data with `status: true` is valid

**Example**:

```gherkin
# ‚úÖ CORRECT - Flexible validation:
Then the response should have status code 200
And the response should contain "response"  # Just check field exists

# ‚ùå WRONG - Rigid validation:
Then the response should have status code 200
And the response should have status "true"   # Fails for empty results
And the response should contain "response"   # Fails if checking not-null
```

### 5. Data-Driven Approach

**testData.json structure** - All request payloads centralized:

```json
{
  "endpoints": {
    "dsbudget/v1/details": {
      "request": {
        "franchiseNumber": [8439, 8345],
        "seasonName": "SM25",
        "businessUnit": ["G3-02"]
      },
      "expectedInResponse": {
        "status": true,
        "error": null
      },
      "_comment": "Describe endpoint purpose and data dependencies"
    }
  }
}
```

**Step Definition** - Clean and data-driven (5-15 lines):

```java
@When("I send a POST request to {string} with valid payload")
public void i_send_post_request(String endpoint) {
    String key = endpoint.replace("/api/", "");
    Map<String, Object> payload = TestDataLoader.getRequestData(key);
    Response response = given()
        .spec(RequestSpecFactory.getAuthRequestSpec())
        .body(payload)
        .when().post(endpoint);
    context.setResponse(response);
}
```

---

## üìã Generation Checklist

### Parse Swagger Endpoint Details

* [ ] **Extract HTTP method**: GET, POST, PUT, DELETE, PATCH from Swagger path definition
* [ ] **Check for path parameters**: Look in `parameters` array where `in: "path"`
* [ ] **Get parameter types**: Extract `schema.type` (integer, string, boolean, etc.)
* [ ] **Extract ALL response codes**: Parse `responses` section for 200, 201, 400, 401, 403, 404, 500
* [ ] **Extract response schema**: Navigate to `components.schemas.SchemaName.properties`
* [ ] **Get actual field names**: Use "response"/"data"/"result" from schema properties
* [ ] **Identify error descriptions**: Read error response descriptions from Swagger
* [ ] **Plan test data**: Valid data for 2xx, invalid for 400, non-existent for 404
* [ ] **Validate test data**: Ensure product IDs, seasons, resources exist in the system

### Generate Feature Files

**Feature File Template:**

```gherkin
@endpoint-name @positive @smoke
Scenario: Successfully call endpoint with valid request
  Given the API base URL is configured
  And authentication is set up
  When I send a [GET|POST|PUT|DELETE] request to "/api/endpoint/v1/path"
  Then the response should have status code [200|201|204]
  And the response should contain "response"

@endpoint-name @negative @no-auth
Scenario: Attempt to call endpoint without authentication
  When I send a [GET|POST|PUT|DELETE] request to "/api/endpoint/v1/path" without authentication
  Then the response should have status code 401
```

**Method-Specific Examples:**
```gherkin
# GET with path parameter (string):
When I send a GET request to "/api/favourites/v1/listing/SM25"

# GET with path parameter (integer):
When I send a GET request to "/api/virtualsalesplan/v1/getSalesPlan/3621"

# POST with request body:
When I send a POST request to "/api/windowsandcamp/v1/listing" with valid payload
```

### Generate testData.json

* [ ] One entry per endpoint: `endpoints.<path>.request`
* [ ] Only business-critical fields (Swagger required fields auto-generated)
* [ ] Add `expectedInResponse` for validation

### Generate Step Definitions

* [ ] Use `TestDataLoader.getRequestData(endpoint)`
* [ ] 5-15 lines per step
* [ ] No if-else blocks for payloads

### Generate Helpers

* [ ] `TestDataLoader.java` - Load from testData.json
* [ ] `RequestSpecFactory.java` - Auth request specs (basic, bearer, JWT, custom headers)
* [ ] `ConfigReader.java` - Read .env file

**RequestSpecFactory Pattern**:

```java
public class RequestSpecFactory {
    public static RequestSpecification getAuthRequestSpec() {
        String authType = ConfigReader.getProperty("AUTH_TYPE", "jwt");
        RequestSpecification spec = new RequestSpecBuilder()
            .setBaseUri(ConfigReader.getProperty("BASE_URL"))
            .setContentType(ContentType.JSON)
            .build();
        
        // Add authentication based on AUTH_TYPE (basic, bearer, jwt, custom)
        return addAuthentication(spec, authType);
    }
}
```

---

## üéØ Framework Architecture Principles

### Data-Driven Approach (MANDATORY)

* **Centralized Data**: Use `testData.json` for all request payloads
* **Auto-Generation**: Swagger-defined required fields auto-generated if missing from `testData.json`
* **No Hardcoding**: Never hardcode values in step definitions‚Äîuse `TestDataLoader.getRequestData(endpoint)`

### Clean Step Definitions

* Step definitions: **5-15 lines max**
* Load data from TestDataLoader
* **Avoid**: Complex `if-else` blocks for payloads

---

## üö® Test Coverage Requirements

* **Positive Scenarios**: Ensure all endpoints with 200/201/204 status codes are validated.
* **401 Unauthorized Tests**: Always generate tests for `401 Unauthorized` for all HTTP methods (GET, POST, PUT, DELETE).
* **Other Error Scenarios**: Generate tests for other error codes (400, 403, 404, 500) if documented in Swagger.

---

## üìÅ Project Structure

```
src/
‚îú‚îÄ‚îÄ test/
‚îÇ   ‚îú‚îÄ‚îÄ java/com/api/automation/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ helpers/BaseAPIHelper.java        # Base class for API calls
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ helpers/TestDataLoader.java       # Loads test data from testData.json
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ config/ConfigReader.java          # Reads environment variables and config
‚îÇ   ‚îú‚îÄ‚îÄ resources/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ schemas/order-response-schema.json # JSON schemas for validation
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ testdata/testData.json           # Centralized test data
```

---

## üîß Technical Stack

**Dependencies**:

* Java 17
* Maven 3.8+
* REST Assured 5.3+
* Cucumber 7.14+
* TestNG 7.8+
* Jackson Databind 2.15+

**pom.xml**:

```xml
<dependencies>
    <!-- REST Assured -->
    <dependency>
        <groupId>io.rest-assured</groupId>
        <artifactId>rest-assured</artifactId>
        <version>5.3.2</version>
    </dependency>
    <dependency>
        <groupId>io.rest-assured</groupId>
        <artifactId>json-schema-validator</artifactId>
        <version>5.3.2</version>
    </dependency>

    <!-- Cucumber -->
    <dependency>
        <groupId>io.cucumber</groupId>
        <artifactId>cucumber-java</artifactId>
        <version>7.14.0</version>
    </dependency>

    <!-- TestNG -->
    <dependency>
        <groupId>org.testng</groupId>
        <artifactId>testng</artifactId>
        <version>7.8.0</version>
    </dependency>
    
    <!-- JSON Processing -->
    <dependency>
        <groupId>com.fasterxml.jackson.core</groupId>
        <artifactId>jackson-databind</artifactId>
        <version>2.15.3</version>
    </dependency>
    
    <!-- Extent Reports -->
    <dependency>
        <groupId>com.aventstack</groupId>
        <artifactId>extentreports</artifactId>
        <version>5.1.1</version>
    </dependency>
    
    <!-- Allure Reports -->
    <dependency>
        <groupId>io.qameta.allure</groupId>
        <artifactId>allure-cucumber7-jvm</artifactId>
        <version>2.24.0</version>
    </dependency>
</dependencies>
```

---

## üìä Reporting Configuration

**Extent Reports**:

```properties
extent.reporter.spark.start=true
extent.reporter.spark.out=reports/extent-reports/ExtentReport.html
extent.reporter.spark.config=src/test/resources/extent-config.xml
```

**Hooks.java with Extent Reports**:

```java
public class Hooks {
    private static ExtentReports extent;
    private static ThreadLocal<ExtentTest> extentTest = new ThreadLocal<>();

    @BeforeAll
    public static void setupExtentReports() {
        ExtentSparkReporter sparkReporter = new ExtentSparkReporter("reports/extent-reports/ExtentReport.html");
        extent = new ExtentReports();
        extent.attachReporter(sparkReporter);
        extent.setSystemInfo("Environment", ConfigReader.getProperty("ENV", "QA"));
        extent.setSystemInfo("Base URL", ConfigReader.getProperty("BASE_URL"));
    }

    @Before
    public void beforeScenario(Scenario scenario) {
        ExtentTest test = extent.createTest(scenario.getName());
        extentTest.set(test);
    }

    @After
    public void afterScenario(Scenario scenario) {
        if (scenario.isFailed()) {
            extentTest.get().fail("Scenario Failed");
        } else {
            extentTest.get().pass("Scenario Passed");
        }
    }

    @AfterAll
    public static void tearDownExtentReports() {
        extent.flush();
    }
}
```

**Allure Reports**:

```xml
<dependency>
    <groupId>io.qameta.allure</groupId>
    <artifactId>allure-cucumber7-jvm</artifactId>
    <version>2.24.0</version>
</dependency>
```

---

## üêõ Common Issues - Quick Reference

| Error | Root Cause | Quick Fix |
|-------|------------|----------|
| `404 Not Found` | Wrong HTTP method or path | Check Swagger: GET vs POST, verify path parameters |
| `400 Bad Request` | Wrong parameter type | Check Swagger: integer vs string, validate values |
| `401 Unauthorized` | Expired/missing JWT token | Refresh token, verify `$env:JWT_TOKEN` is set |
| `Expected 200 got 201` | Wrong expected status code | Update feature file to expect 201 for create operations |
| `status: false` when expecting true | Invalid test data or empty result | Use valid resource IDs or accept false as legitimate |

---

## üé¨ Quick Start

1. **Read** `.env` for BASE_URL, AUTH_TYPE, credentials
2. **Parse** Swagger response schemas ‚Üí extract field names
3. **Generate**:

   * testData.json (endpoints structure)
   * Feature files (use schema field names!)
   * Step definitions (5-15 lines, use TestDataLoader)
   * Helpers (RequestSpecFactory, TestDataLoader, ConfigReader)
   * Hooks (with Extent Reports integration)
4. **Run**: `mvn clean test`
5. **Reports**:

   * Cucumber: `reports/cucumber-reports/cucumber.html`
   * Extent: `reports/extent-reports/ExtentReport.html`
   * Allure: `mvn allure:serve`

---

### **Completion Criteria**

* ‚úÖ All test scenarios execute successfully
* ‚úÖ Three-level validation (schema, data type, key values) implemented
* ‚úÖ Retry logic configured for stability
* ‚úÖ Multiple report formats generated
* ‚úÖ Centralized configuration and test data
* ‚úÖ Flexible authentication support
* ‚úÖ Proper logging and debugging capabilities
* ‚úÖ CI/CD ready with Maven integration
* ‚úÖ Code follows Java and REST Assured best practices
* ‚úÖ Comprehensive documentation in place


Swagger has swagger definitions... 2. Testdata.json has request, business critical response... 3. For any endpoint, for the request body, look at the testdata.json for the testdata. if its available use it, otherwise use faker and generate random value based on schema from the swagger. Only for required fields. Don't consider optional ones.
3 level validations need to be happened in the response. 5. Whatever status is available like 200, 400 etc., GHCP need to generate test scripts. Additionally 401 regardless of status code specification in the swagger. 6. endpoint-config.json gives clarity on endpts need to be tested... Is all these covered in copilot-instructions or does these in sync with copilot-instructions ?
---
