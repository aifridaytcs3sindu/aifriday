Here’s an updated version of your Confluence page that includes the requested workflow:

---

# Playwright + CucumberJS Test Automation Framework

## Objective

This framework automates UI testing for web applications using Playwright in combination with CucumberJS (BDD style). It follows best practices for scalability, maintainability, and reusability, ensuring automatic execution of tests with self-healing and retry mechanisms for any failures.

## Framework Structure

### Key Components:

1. **Feature Files** (`.feature`):

   * Written in Gherkin syntax, these contain the BDD scenarios for automation.

2. **Step Definitions** (`.steps.ts`):

   * The implementation of Given/When/Then steps in TypeScript, using Playwright for automation.

3. **Page Objects** (`.page.ts`):

   * Reusable classes that encapsulate interactions with web pages.

### Folder Structure

```
features/
  └─ [feature-name].feature          # BDD scenarios
steps/
  └─ [feature-name].steps.ts         # Step definitions
tests/
  └─ pages/                          # Page objects
    └─ [PageName]Page.ts             # Specific page actions (e.g., LoginPage.ts)
support/
  └─ hooks.ts                       # Playwright test hooks
  └─ fixtures.ts                    # Custom fixtures
  └─ retry-helper.ts                # Retry logic
```

## Workflow

### Step 1: Input Configuration

* **.env**: Contains non-sensitive configuration, such as `baseUrl`.
* **requirements.xlsx**: Contains the business requirements and user journey steps that will be parsed into test scenarios.

### Step 2: User Journey Creation

* **Parse the `requirements.xlsx`** to extract user journeys and acceptance criteria.
* **Generate user journeys** in a structured markdown format (`user-journeys.md`) from the input Excel file.

### Step 3: BDD Artifacts Generation

* **Feature files** (`.feature`) are generated using the Gherkin syntax based on the user journey.
* **Step definition files** (`.steps.ts`) are created to implement the Given/When/Then steps using Playwright commands.
* **Page objects** (`.page.ts`) are created for reusable page interaction logic.

### Step 4: Test Execution

* **Execute tests** using Playwright's `npm test` command.
* If tests fail, apply **self-healing** by running discovery tests, identifying real selectors, and fixing the issues.

### Step 5: Post-Execution Actions

* **Re-run all tests** after applying fixes to ensure all tests pass.
* **Generate reports** (HTML, JSON, JUnit) with Playwright’s built-in reporting functionality.

### Step 6: Final Documentation

* **Test execution summary**: A summary of test results (pass/fail, scenarios executed).
* **Generate `README.md`**: Document the entire testing setup, instructions, and any specific configurations used.

## Best Practices

1. **Selectors**: Always extract selectors from the DOM using discovery tests. Never assume their existence or structure.
2. **Test Execution**: Automatically run all tests after they are generated. Fix failures immediately by running discovery tests and updating the code.
3. **Retries**: Implement retry mechanisms for unstable selectors or intermittent failures.
4. **Reporting**: Use Playwright's built-in report generation features to analyze test results. Always validate that all tests pass before sharing.

## Common Pitfalls

* **Flaky Tests**: Ensure that waits and retries are applied where necessary, particularly in SPA apps with slow loading times.
* **Incorrect Selectors**: Run discovery tests on failures to ensure that selectors are accurate and up-to-date.

---

This updated version reflects the entire process, from input files to test execution, self-healing, and generating final documentation. Let me know if you need further changes!
